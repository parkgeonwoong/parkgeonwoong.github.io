{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"첫 글","text":"제목입니다.안녕하세요","link":"/2022/01/12/%EC%B2%AB-%EA%B8%80/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/01/12/hello-world/"},{"title":"Interactive-scroll","text":"📌 스크롤 값을 활용한 인터랙티브 패럴랙스는 레이어가 존재해야 한다. (멈춰 있는 레이어, 천천히 움직이는 레이어, 빨리 움직이는 레이어, 시선) 스크롤 값을 받아오는 것 부터 시작 Parallax Scrolling : 사용자가 스크롤할 때 배경 이미지가 느리게 움직이며, 근거리를 빨리 움직이는 즉 입체감을 느낄 수 있는 디자인 기법 스크롤을 움직일 때마다 transform의 translate, scale, opacity 등 변화를 직접 준다. CSS 그라디언트 적용 1background: linear-gradient(150deg, tomato, orange, white); ✅ 스크롤 값 받아오기123window.addEventListener(&quot;scroll&quot;, function (e) { scrollTop = document.documentElement.scrollTop;}); ✅ 화면 width 길이의 스크롤 바 구현. 백분율 구하는 공식. 가로 퍼센트값 = 현재 스크롤 탑 위치 / (문서 전체 길이 - 윈도우 창 높이 ) * 100; 1234per = Math.round( scrollTop / (document.documentElement.scrollHeight - window.innerHeight) ) * 100; ✅ scrollTop 패럴렉스 구현12345678910window.addEventListener(&quot;scroll&quot;, function (e) { scrollTop = document.documentElement.scrollTop; let per = Math.ceil( (scrollTop / (document.body.scrollHeight - window.outerHeight)) * 100 ); bar.style.height = per + &quot;%&quot;; cloudWrap.style.transform = &quot;translate(0,&quot; + scrollTop / 1.2 + &quot;px)&quot;;}); (윈도우 기준) 스크롤 한 번에 100픽셀씩 이동 모두가 100씩 이동할때 지정한 오브젝트만 100 / 1.2 = 83.3 씩 이동을 하게 되어 느리게 움직이는 느낌 반대로 100 * .8 로 해도 비슷한 결과","link":"/2022/01/15/interactivek/Interactive-scroll/"},{"title":"Interactive-addition","text":"✅ 인터랙티브 교차 페이징 사진 여러개를 position fixed로 겹쳐서 JS에 의해 사진이 달라지는 교차페이지 123456//선택된 컨텐츠랩 활성contentWrap[pageNum].classList.add(&quot;active&quot;);for (var i = 0; i &lt; 4; i++) { //활성된 컨텐츠랩 내부 이미지들 활성 contentWrap[pageNum].getElementsByTagName(&quot;img&quot;)[i].classList.add(&quot;active&quot;);} ✅ translateZ 활용한 입체적인 페이지 translateZ : 앞 뒤로 움직여서 입체감을 높여준다 perspective : 깊이감을 준다. 적으면 변화가 빠르고, 높으면 변화가 천천히 123456789101112131415161718192021222324let scrollTop = 0;let imageAll;let totalNum = 0;window.onload = function () { progressBar = document.getElementsByClassName(&quot;progressBar&quot;)[0]; imageAll = document.querySelectorAll(&quot;.parallax_image&quot;); totalNum = imageAll.length; window.addEventListener(&quot;scroll&quot;, scrollFunc);};function scrollFunc(e) { scrollTop = this.scrollY; for (var i = 0; i &lt; totalNum; i++) { imageAll[i].style.transform = &quot;perspective(400px) translateZ(&quot; + scrollTop / (5 * (totalNum - i)) + &quot;px)&quot;; // imageAll[i].style.transform = &quot;perspective(400px) translateZ(&quot;+ scrollTop/5 +&quot;px)&quot;; 동시에 움직여 입체감이 없다 }}","link":"/2022/01/15/interactivek/Interactive-addition/"},{"title":"Interactive mouse","text":"📌 Mouse를 활용한 인터렉티브✅ mouse move 활용123window.addEventListener(&quot;mousemove&quot;, function(e) { console.log(e.clientX, e.clientY);} 위에 처럼 마우스 X, Y 좌표가 직접 console에 찍힌다. 1document.getElementsByClassName(&quot;className&quot;)[0]; 배열로 넘어오기 때문에 첫번째 요소인 [0]을 선택해준다. ✅ requestAnimationFrame == loop loop라는 자연스럽게 움직이게 활용 화려한 애니메이션 &amp; 3D 컨텐츠에 활용 12345function loop() { console.log(&quot;계속 실행됩니다.&quot;); window.requestAnimationFrame(loop);} ✅ 자연스러운 마우스 움직임 CSS 속성을 JS에서 사용하는 방법 12345item.style.transform = &quot;translate(&quot;+ x값 + &quot;px, &quot; + Y값 +&quot;px)&quot;;CSS : item { transform : translate(100px, 100px); }JS: item.style.transform = &quot;translate(100px, 100px)&quot;; ➡️ 마우스 자연스러운 움직이는 공식 1mx += (x - mx) * speed; 움직일 값 += (현재 마우스 위치 - 바로 전 위치 값) * 0.001; 현재 위치가 100, 마우스 현재 위치가 150이라고 치면! 100부터 50만큼 이동을 하면 되는데.한 번에 50을 더해주면 바로 착! 이동을 하니까 조금씩 작은 수를 더해주는 겁니다.100 += (150 - 100) * 0.001; 이렇게 계산 된 수를 계속 더해주는 방식. ✅ transition, easing (가속도)easing test transition은 시간에 대한 변화량이다. easing은 가속도로써 변화를 줄 수 있다. 🔸 정리 마우스의 x, y 좌표를 JS로 직접 찍어보면서 기본 개념 다루기 requestAnimationFrame을 이용하여 콜백함수로 60프레임을 &gt; 다루어 자연스러운 animation 효과를 나타낸다. 마우스의 자연스러운 움직임을 위해서 시간차에 따른 변화량을 &gt; 사용 (loop = requestAnimationFrame) CSS속성을 JS로 나타내어 필요한 부분, 세심한 부분에 CSS &gt; 속성을 대입한다.","link":"/2022/01/14/interactivek/Interactive-mouse/"},{"title":"자료구조 basic","text":"✅ 정의 대량의 데이터를 효율적으로 관리할 수 있도록 하는 데이터의 구조를 의미합니다. 데이터 특성에 따라서, 체계적인 데이터 구조화가 필요하며, 이러한 데이터 구조는 코드의 효율성, 성능을 결정합니다. ✅ 종류대표적인 자료구조로는 배열(Array), 스택(Stack), 큐(Queue), 링크드 리스트(Linked List), 해쉬 테이블(Hash Table), 힙(Heap) 등이 존재합니다. Python에서는 대표적으로 List, tuple, set, dictionary가 존재하며, 위의 자료구조 대부분을 모두 구현이 가능합니다. 🔥 스택 스택의 추상 자료형 (스택으로 무엇을 할 수 있는가?) 스택이 비어있는지 새로운 항목을 스택에 삽입 스택에서 하나의 항목을 꺼낸다 스택의 현재 개수 맨위 스택이 무엇인지 알려준다 스택을 깨끗이 비운다. 스택은 어디서 사용? 페이지 되돌리기 함수 호출에서 복귀 주소 괄호 닫기 계산기 프로그램 깊이 우선 탐색 🔥 큐 큐는 어디서 사용? 서비스 콜 센터 콜큐 인쇄 작업 큐 버퍼링 시뮬레이션 이진트리의 레벨 순회, 기수정렬에서 레코드의 정렬, 너비우선탐색 🔥 덱 큐의 front 와 rear에서 모두 삽입 삭제가 가능한 큐 🔥 우선순위 큐 모든 데이터가 우선순위를 가지고 있고, 들어온 순서와 상관없이 우선순위가 높은 데이터가 먼저 출력되는 구조 우선순위 큐는 “우선순위”에 따라 스택이나 큐로 얼마든지 사용 우선순위 큐 주요 응용 허프만 코딩 트리 크루스칼 최소비용 신장트리 알고리즘 다익스트라 최단거리 알고리즘 상태공간트리","link":"/2022/01/14/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-basic/"},{"title":"Element 렌더링","text":"📌 Element 렌더링https://ko.reactjs.org/docs/rendering-elements.html 엘리먼트는 React 앱의 가장 작은 단위 브라우저 DOM 엘리먼트와 달리 React 엘리먼트는 일반 객체이며(plain object) 쉽게 생성할 수 있습니다. React DOM은 React 엘리먼트와 일치하도록 DOM을 업데이트한다 1&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 이 안에 들어가는 모든 엘리먼트를 React DOM에서 관리하기 때문에 이것을 “루트(root)” DOM 노드라고 부른다 React 엘리먼트를 루트 DOM 노드에 렌더링하려면 [ReactDOM.render()](https://ko.reactjs.org/docs/react-dom.html#render)로 전달 UI를 업데이트하는 유일한 방법은 새로운 엘리먼트를 생성하고 이를 ReactDOM.render()로 전달 1234567891011function tick() { const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render(element, document.getElementById(&quot;root&quot;));}setInterval(tick, 1000);","link":"/2022/01/20/react/Element-%EB%A0%8C%EB%8D%94%EB%A7%81/"},{"title":"JSX","text":"📌JSXHello World - React 📌JSX ✅ JSX 소개 ✅ JSX에 표현식 포함하기 ✅ JSX문법 ✅ 기초 사용법 🔸 If문 사용 🔸 AND &amp;&amp; 🔸 OR || 🔸 인라인 스타일링 src/APP.js 불러오기 import로 불러오는 기능을 브라우저에서도 사용하기 위해 번들러를 사용 번들 : 파일을 묶듯이 연결하는 것. 대표적인 것 → 웹팩, Parcel, browserify 1234function App() { return ( ....)} function 키워드를 사용하여 컴포넌트를 만들었다 → 함수 컴포넌트라고 부른다. ✅ JSX 소개1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; JavaScript를 확장한 문법이다. React ‘엘리먼트’를 생성한다. JSX 장점 보기 쉽고 익숙하다 → JS만 사용한 코드와 JSX 비교 높은 활용도 → HTML 태그를 사용하고 컴포넌트도 JSX안에서 작성할 수 있다. 12345678910111213# ReactDOM.render- 컴포넌트를 페이지에 렌더링하는 역할- react-dom 모듈을 불러와 사용# 함수의 파라미터ReactDOM.render(페이지에 렌더링할 내용 JSX형태, JSX를 렌더링할 document 내부 요소 설정)# React.StrictMode- 레거시 기능들을 사용하지 못하게 하는 기능- 옛날 기능을 사용했을 때 경고를 출력 ✅ JSX에 표현식 포함하기1234const name = &quot;Josh Perez&quot;;const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;ReactDOM.render(element, document.getElementById(&quot;root&quot;)); JSX의 중괄호 안에는 유효한 모든 javaScript 표현식을 넣을 수 있다 컴파일이 끝나면, JSX 표현식이 정규 JavaScript 함수 호출이 되고 JavaScript 객체로 인식 ✅ JSX문법 감싸인 요소 리액트 컴포넌트에서 요소 여러 개를 왜 하나의 요소로 꼭 감싸야 하는가? Virtual DOM에서 컴포넌트 변화를 감지해 낼 때 효율적으로 비교할 수 있도록 컴포넌트 내부는 하나의 DOM 트리 구조로 이루어져야 한다는 규칙 또는 리액트 v16 도입된 Fragment 기능 사용 ✅ 기초 사용법 src/index.js에서 직접 고쳐도 되지만 모듈을 분리해 실행만 하게 src/App.js에서 수정해보자 12345678910111213import &quot;./App.css&quot;;function App() { const name = &quot;React&quot;; return ( &lt;div&gt; &lt;h1&gt;{name} 안녕? &lt;/h1&gt; &lt;h2&gt;React Document&lt;/h2&gt; &lt;/div&gt; );}export default App; 🔸 If문 사용 if (어쩌구) {저쩌구} 이게 안된다는 소리 JSX안에서 쓰는 삼항 연산자 → 조건문 ? 조건문 참일때 실행할 코드 : 거짓일 때 실행할 코드 1234function App() { const name = &quot;React&quot;; return &lt;div&gt;{name === &quot;React&quot; ? &lt;h1&gt;check&lt;/h1&gt; : null}&lt;/div&gt;;} 🔸 AND &amp;&amp; 조건이 맞으면 뜨고 안맞으면 안뜨게 &amp;&amp; 연산자로 조건부 렌더링 할 수 있는 이유 → 리액트에서 false를 렌더링할 때는 null과 마찬가지로 아무것도 나타나지 않기 때문 1234function App() { const name = &quot;React&quot;; return &lt;div&gt;{name === &quot;React&quot; &amp;&amp; &lt;h1&gt;react&lt;/h1&gt;}&lt;/div&gt;;} 🔸 OR || undefined만 반환하여 렌더링하는 상황을 만들때 1234function App() { const name = undefined; return &lt;div&gt;{name || &lt;h1&gt;react&lt;/h1&gt;}&lt;/div&gt;;} 🔸 인라인 스타일링 리액트에서 DOM 요소에 스타일을 적용할 때는 문자열 형태로 넣는 것이 아니라 객체 형태로 넣어주어야 한다. 카멜 표기법 → background-color X → backgroundColor JSX에는 class가 아닌 className으로 설정해 주어야 한다. (APP.css에서 설정하고 ) 123456789101112131415function App() { const name = &quot;React&quot;; return ( &lt;div style={{ backgroundColor: &quot;black&quot;, color: &quot;aqua&quot;, fontSize: &quot;48px&quot;, fontWeight: &quot;bold&quot;, }} &gt; {name} &lt;/div&gt; );} 12345678910function App() { const name = &quot;React&quot;; const style = { backgroundColor: &quot;black&quot;, color: &quot;aqua&quot;, fontSize: &quot;48px&quot;, fontWeight: &quot;bold&quot;, }; return &lt;div style={style}&gt;{name}&lt;/div&gt;;} 주석 12345678910111213function App() { const name = &quot;React&quot;; return ( &lt;div&gt; {/* 이렇게 주석 */} &lt;div className=&quot;react&quot; // 이렇게 할수도 있넹 &gt; {name} &lt;/div&gt; &lt;/div&gt; );}","link":"/2022/01/18/react/JSX/"},{"title":"React-Document","text":"📌React DocumentReact - 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리 React는 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리 📌React Document ✅ 선언형 ✅ 컴포넌트 기반 ✅ 간단한 컴포넌트 ✅ 상태를 가지는 컴포넌트 ✅ 외부 플러그인을 사용하는 컴포넌트 ✅ 리액트의 특징 ✅ Create React APP ✅ 선언형 상호작용이 많은 UI를 만들 때 → 어려움을 줄여줌 애플리케이션의 각 상태에 대해 → 뷰 만 설계 데이터가 변경됨에 따라 컴포넌트 → 갱신하고 렌더링 1234567**어떤 데이터가 변할 때마다 어떤 변화를 줄지 고민하는 것이 아니라그냥 기존 뷰를 날려 버리고 처음부터 새로 렌더링하는 방식**- 새롭게 리렌더링하면서 성능을 아끼고, 최적의 UX을 제공할 수 있을까? 데이터 업데이트시 업데이트한 값을 수정하는 것이 아니라, render 함수를 또 다시 호출 이때 render함수가 반환하는 결과를 DOM에 반영하지 않고, 이전에 render 함수가 만든 컴포넌트 정보와 현재 컴포넌트를 비교하여 -&gt; 둘의 차이를 최소한 연산으로 DOM 트리 업데이트 ✅ 컴포넌트 기반 컴포넌트 : 스스로 상태를 관리하는 캡슐화 조합해 복잡한 UI를 만듬 컴포넌트 로직 → 템플릿 X, Javascript로 작성 다양한 형식의 데이터를 앱 안에서 전달, DOM과는 별개로 상태를 관리 123456789# 컴포넌트- React 프로젝트에서 특정 부분이 어떻게 생길지 정하는 선언체- 재사용이 가능한 API로 수 많은 기능들을 내장- 컴포넌트 하나에서 해당 컴포넌트의 생김새와 작동 방식을 정의# 렌더링- 사용자 화면에 뷰를 보여 주는 것 ✅ 간단한 컴포넌트 React 컴포넌트는 render( ) 메서드를 구현 → 데이터를 입력받아 화면에 표시할 내용을 반환하는 역할 컴포넌트로 전달된 데이터는 render( ) 안에서 this.props를 통해 접근 1234# render()- 컴포넌트가 어떻게 생겼는지 정의하는 역할- 뷰가 어떻게 생겼고, 어떻게 작동하는지에 대한 정보를 지닌 객체를 반환 ✅ 상태를 가지는 컴포넌트 컴포넌트는 this.props를 이용해 → 입력 데이터 + 내부적인 상태 데이터를 가짐 이는 this.state로 접근할 수 있다. 컴포넌트의 상태 데이터가 바뀌면 → render()가 다시 호출되어 마크업 갱신 ✅ 외부 플러그인을 사용하는 컴포넌트 React는 다른 라이브러리나 프레임워크 함께 활용 ✅ 리액트의 특징 Virtual DOM을 사용하는 것 DOM : 객체로 문서 구조를 표현하는 방법으로 XML, HTML로 작성 Virtual DOM을 사용하면 → 실제 DOM에 접근하여 조작하는것이 아닌 추상화한 JS 객체를 구성하여 사용 1231. 데이터를 업데이트하면 전체 UI를 Virtual DOM에 리렌더링한다.2. 이전 Virtual DOM에 있던 내용과 현재 내용을 비교한다3. 바뀐 부분만 실제 DOM에 적용한다. ✅ Create React APP123npx create-react-app my-appcd my-appnpm start","link":"/2022/01/16/react/React-Document/"}],"tags":[],"categories":[{"name":"Test","slug":"Test","link":"/categories/Test/"},{"name":"Interactive","slug":"Interactive","link":"/categories/Interactive/"},{"name":"자료구조","slug":"자료구조","link":"/categories/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"Document","slug":"React/Document","link":"/categories/React/Document/"}]}