{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/01/12/hello-world/"},{"title":"1. 인터넷 네트워크","text":"📌 인터넷 네트워크 📌 인터넷 네트워크 정리 ✅ 인터넷 통신 🔸 인터넷에서 컴퓨터 둘은 어떻게 통신할까? ✅ IP (인터넷 프로토콜) 🔸 인터넷 프로토콜 역할 🔸 IP 프로토콜의 한계 ✅ TCP, UDP 🔸 인터넷 프로토콜 스택의 4계층 🔹 TCP 특징 🔸 연결 지향 🔸 데이터 전달 보증 🔸 순서 보장 🔸 UDP 특징 ✅ PORT ✅ DNS (Domain Name System) 이미지 참고: https://velog.io/@dnstlr2933/HTTP-웹-기본학습 정리123456789101112# 복잡한 인터넷 망을 메시지 보내기 위해서1. 인터넷 프로토콜 (IP)가 존재 -&gt; 하지만 ip만으로는 메시지가 도착했는지, 순서가 꼬일수도 해결책은?2. TCP 프로토콜이 해결- UDP는 IP랑 똑같은데 PORT 정도만 추가되는 백지 + 애플리케이션 확장 기능3. PORT = 같은 IP에서 동작하는 애플리케이션을 구분4. IP는 변하기 쉽고 외우기 어려운데 도메인명을 등록해 쉽게 관리 ✅ 인터넷 통신🔸 인터넷에서 컴퓨터 둘은 어떻게 통신할까? https://velog.io/@dnstlr2933/HTTP-웹-기본학습 ➡️ 복잡한 인터넷 망을 두고 클라이언트끼리 통신을 주고받을 수 있는 이유 IP 인터넷 프로토콜 ✅ IP (인터넷 프로토콜) 우선적으로 보내고자하는 내 클라이언트가 IP주소를 부여받아야 하고, 받고자하는 상대방도 IP주소가 있어야한다 IP 주소가 부여받아야 한다. 그리고 나서 출발 주소, 목적 주소를 알고 메시지를 인터넷에 던진다 노드로 연결된 인터넷끼리 주고 받다가 맞는 IP에 보냄 🔸 인터넷 프로토콜 역할 지정한 IP 주소에 데이터 전달 패킷(Packet)이라는 통신 단위로 데이터 전달 IP 패킷 정보 → 출발지 IP, 목적지 IP, 기타 하지만 패킷만으로는 한계가 있다 🔸 IP 프로토콜의 한계 비연결성 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송 비 신뢰성 중간에 패킷이 사라지면? 패킷이 순서대로 안오면? 프로그램 구분 같은 ip를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면? ➡️ 이런 한계를 해결하기 위해 TCP / UDP가 등장 ✅ TCP, UDP🔸 인터넷 프로토콜 스택의 4계층 애플리케이션 계층 - HTTP, FTP 전송 계층 - TCP, UDP 인터넷 계층 - IP 네트워크 인터페이스 계층 https://velog.io/@dnstlr2933/HTTP-웹-기본학습 하나하나 봐보면 IP 패킷 정보 → 출발지 ip, 목적지 ip 패킷 = 패키지 + 버켓의 합성어, 즉 담는 공간이라 보자 TCP/IP 패킷 정보 → ip 패킷 외에도 출발지, 목적지 PORT, 전송제어, 순서, 검증 정보 🔹 TCP 특징전송 제어 프로토콜 - Transmission Control Protocol 연결 지향 - TCP 3-way handshake (가상연결) 데이터 전달 보증 순서 보장 신뢰할 수 있는 프로토콜 대부분의 애플리케이션에서 TCP를 사용 결국 이러한 특징들은 TCP에서 전송 제어, 순서등에서 처리하기에 가능한 특징들이다 특징을 살펴보면 🔸 연결 지향 클라이언트와 서버가 서로 SYN 과 ACK를 보냄으로 서로를 확인하고 → 데이터를 전송 🔸 데이터 전달 보증 🔸 순서 보장 패킷2가 와야하는데 패킷3이 왔네? → 뒤에 전부 버리고 다시 패킷2 부터 요청 🔸 UDP 특징→ PORT 하나의 ip에서 여러 어플리케이션을 분리하는 것 사용자 데이터그램 프로토콜(User Datagram Protocol) 하얀 도화지에 비유(기능이 거의 없음) 연결지향 - TCP 3 way handshake X 데이터 전달 보증 X 순서 보장 X 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름 정리 IP와 거의 같다. +PORT +체크섬 정도만 추가 애플리케이션에서 추가 작업 필요 ➡️ UDP를 왜 쓰는가? TCP는 최적화가 어렵다. UDP는 아무것도 없기에 직접 만들어 사용 ✅ PORT➡️ 한번에 둘 이상 연결해야 하면 어떻게 할까? IP패킷들이 서버에서 클라이언트로 들어올텐데 이때 어떻게 해당 패킷들을 구별해서 필요한 프로그램에게 전달할 것인가? → 포트번호를 부여 TCP에서 패킷에 출발지의 PORT번호 + 도착지의 PORT번호 정보를 담는다 사실상 패킷 → TCP/IP 패킷으로 구성 같은 IP내에서 프로세스를 구분하기 위해 PORT를 사용하는 것 비유 → IP : 아파트 , PORT : 동, 호수 개념 위 그림에 맞게 설명 하면 클라이언트 IP 주소로 패킷구성(ip, port) 웹 브라우저 요청으로 서버에 도착 port는 80 서버에서 패킷을 열어보니 ip주소와 port를 보고 10010 포트인걸 보니 웹브라우저구나 생각 ✅ DNS (Domain Name System)➡️ IP의 문제점 IP는 기억하기 어렵다 IP는 변경될 수 있다 이를 해결하기 위해 DNS이 탄생 전화번호부 같은 도메인 명을 IP주소로 변환 (이름 - 번호) 설명하자면 도메인 명을 사고 IP주소를 등록 클라에서 해당 도메인명으로 접근 DNS서버가 등록된 도메인명의 IP주소를 반환 클라는 반환받은 IP주소를 이용해서 서버에 접속 → 결국 IP주소를 외울 필요 없고, 추후에 IP주소가 변경되더라도 DNS서버에 등록된 IP주소만 변경하면 DNS는 변경되지 않는다","link":"/2022/01/25/http/%EC%9D%B8%ED%84%B0%EB%84%B7-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"},{"title":"2. URI 웹브라우저 요청 흐름","text":"📌 URI와 웹 브라우저 요청 흐름 📌 URI와 웹 브라우저 요청 흐름 ✅ URI 🔹 URL 문법 분석 🔸 scheme 🔸 userinfo 🔸 host 🔸 path 🔸 query 🔸 fragment ✅ 웹 브라우저 요청 흐름 🔸 HTTP 메시지 전송 이미지 참고: https://velog.io/@dnstlr2933/HTTP-웹-기본학습#uri와-웹-브라우저-요청-흐름 ✅ URI Uniform Resource Identifier URI는 locator, name 둘다 또는 추가로 분류될 수 있다 URI → URL + URN Uniform : 리소스 식별하는 통일된 방식 Resource : 자원, URI로 식별할 수 있는 모든 것(제한 없음) Identifier : 다른 항목과 구분하는데 필요한 정보 URL - locator : 리소스가 있는 위치를 지정 URN - Name : 리소스에 이름을 부여 위치는 변할 수 있지만, 이름은 변하지 않는다 URI == URL 같은 의미라고 볼 수 있다 🔹 URL 문법 분석scheme://[userinfo@]host[:port][/path][?query][#fragment] https://www.google.com/search?q=hello&amp;hl=ko 프로토콜 : https 호스트명 : www.google.com 포트번호 : 443 패스 : /search 쿼리 파라미터 : q=hello&amp;hl=ko 🔸 scheme 주로 프로토콜 사용 프로토콜 : 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙 http → 80, https → 443, 포트는 생략 가능 https는 http에 보안 추가 🔸 userinfo 거의 사용하지 않는것으로 URL에 사용자 정보를 포함해서 인증할 때 사용한다 🔸 host 호스트명 도메인명 또는 IP주소를 직접 사용 🔸 path 리소스 경로로 계층적 구조를 갖는다 /home/file.jpg 🔸 query key=value 형태 ?로 시작, &amp;로 추가 가능 → ?keyA=valueA&amp;keyB=valueB query parameter, query string으로 불린다 🔸 fragment html 내부 북마크 등에 사용 서버에 전송하는 정보 아님 ✅ 웹 브라우저 요청 흐름 https://velog.io/@dnstlr2933/HTTP-웹-기본학습#uri와-웹-브라우저-요청-흐름 웹에 위와 같은 URL을 입력하게 되면 HTTP 요청 메시지가 생성된다 12GET/search?q=hello&amp;hl=ko HTTP/1.1Host: www.google.com 🔸 HTTP 메시지 전송 생성된 패킷의 모습 과정은 TCP/IP패킷에 전송 데이터로 http 메시지가 들어간 모습이다 이 패킷이 인터넷 망을 돌다가 원하는 IP주소에 도착하게 되면 해당 서버는 요청 패킷을 받아서 TCP/IP패킷은 벗겨버리고 전송 데이터인 HTTP메시지를 확인하게 된다 http메시지를 확인한 서버는 HTTP 응답 메시지를 다시 클라이언트에게 전달하게 된다 1234567HTTP/1.1 200 OKContent-Type: text/html;charset=UTF-8Content-Length: 3423&lt;html&gt; &lt;boldy&gt;...&lt;/body&gt;&lt;/html&gt; 요청 패킷을 받은 구글서버는 위와 같은 http 응답 메시지를 만들고 다시 TCP/IP 패킷을 씌워서 응답패킷을 인터넷 망에 올려서 전달해준다 최종적으로 요청패킷을 보냈던 웹브라우저(클라이언트)는 응답 패킷을 받고 해당 패킷의 HTTP 메시지를 열어서 HTTP 메시지 안에 들어있는 html 내용물을 웹 브라우저 상에 띄어서 보게 된다","link":"/2022/01/27/http/URI-%EC%9B%B9%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%9A%94%EC%B2%AD-%ED%9D%90%EB%A6%84/"},{"title":"Interactive-addition","text":"✅ 인터랙티브 교차 페이징 사진 여러개를 position fixed로 겹쳐서 JS에 의해 사진이 달라지는 교차페이지 123456//선택된 컨텐츠랩 활성contentWrap[pageNum].classList.add(&quot;active&quot;);for (var i = 0; i &lt; 4; i++) { //활성된 컨텐츠랩 내부 이미지들 활성 contentWrap[pageNum].getElementsByTagName(&quot;img&quot;)[i].classList.add(&quot;active&quot;);} ✅ translateZ 활용한 입체적인 페이지 translateZ : 앞 뒤로 움직여서 입체감을 높여준다 perspective : 깊이감을 준다. 적으면 변화가 빠르고, 높으면 변화가 천천히 123456789101112131415161718192021222324let scrollTop = 0;let imageAll;let totalNum = 0;window.onload = function () { progressBar = document.getElementsByClassName(&quot;progressBar&quot;)[0]; imageAll = document.querySelectorAll(&quot;.parallax_image&quot;); totalNum = imageAll.length; window.addEventListener(&quot;scroll&quot;, scrollFunc);};function scrollFunc(e) { scrollTop = this.scrollY; for (var i = 0; i &lt; totalNum; i++) { imageAll[i].style.transform = &quot;perspective(400px) translateZ(&quot; + scrollTop / (5 * (totalNum - i)) + &quot;px)&quot;; // imageAll[i].style.transform = &quot;perspective(400px) translateZ(&quot;+ scrollTop/5 +&quot;px)&quot;; 동시에 움직여 입체감이 없다 }}","link":"/2022/01/15/interactivek/Interactive-addition/"},{"title":"Interactive mouse","text":"📌 Mouse를 활용한 인터렉티브✅ mouse move 활용123window.addEventListener(&quot;mousemove&quot;, function(e) { console.log(e.clientX, e.clientY);} 위에 처럼 마우스 X, Y 좌표가 직접 console에 찍힌다. 1document.getElementsByClassName(&quot;className&quot;)[0]; 배열로 넘어오기 때문에 첫번째 요소인 [0]을 선택해준다. ✅ requestAnimationFrame == loop loop라는 자연스럽게 움직이게 활용 화려한 애니메이션 &amp; 3D 컨텐츠에 활용 12345function loop() { console.log(&quot;계속 실행됩니다.&quot;); window.requestAnimationFrame(loop);} ✅ 자연스러운 마우스 움직임 CSS 속성을 JS에서 사용하는 방법 12345item.style.transform = &quot;translate(&quot;+ x값 + &quot;px, &quot; + Y값 +&quot;px)&quot;;CSS : item { transform : translate(100px, 100px); }JS: item.style.transform = &quot;translate(100px, 100px)&quot;; ➡️ 마우스 자연스러운 움직이는 공식 1mx += (x - mx) * speed; 움직일 값 += (현재 마우스 위치 - 바로 전 위치 값) * 0.001; 현재 위치가 100, 마우스 현재 위치가 150이라고 치면! 100부터 50만큼 이동을 하면 되는데.한 번에 50을 더해주면 바로 착! 이동을 하니까 조금씩 작은 수를 더해주는 겁니다.100 += (150 - 100) * 0.001; 이렇게 계산 된 수를 계속 더해주는 방식. ✅ transition, easing (가속도)easing test transition은 시간에 대한 변화량이다. easing은 가속도로써 변화를 줄 수 있다. 🔸 정리 마우스의 x, y 좌표를 JS로 직접 찍어보면서 기본 개념 다루기 requestAnimationFrame을 이용하여 콜백함수로 60프레임을 &gt; 다루어 자연스러운 animation 효과를 나타낸다. 마우스의 자연스러운 움직임을 위해서 시간차에 따른 변화량을 &gt; 사용 (loop = requestAnimationFrame) CSS속성을 JS로 나타내어 필요한 부분, 세심한 부분에 CSS &gt; 속성을 대입한다.","link":"/2022/01/14/interactivek/Interactive-mouse/"},{"title":"Interactive-scroll","text":"📌 스크롤 값을 활용한 인터랙티브 패럴랙스는 레이어가 존재해야 한다. (멈춰 있는 레이어, 천천히 움직이는 레이어, 빨리 움직이는 레이어, 시선) 스크롤 값을 받아오는 것 부터 시작 Parallax Scrolling : 사용자가 스크롤할 때 배경 이미지가 느리게 움직이며, 근거리를 빨리 움직이는 즉 입체감을 느낄 수 있는 디자인 기법 스크롤을 움직일 때마다 transform의 translate, scale, opacity 등 변화를 직접 준다. CSS 그라디언트 적용 1background: linear-gradient(150deg, tomato, orange, white); ✅ 스크롤 값 받아오기123window.addEventListener(&quot;scroll&quot;, function (e) { scrollTop = document.documentElement.scrollTop;}); ✅ 화면 width 길이의 스크롤 바 구현. 백분율 구하는 공식. 가로 퍼센트값 = 현재 스크롤 탑 위치 / (문서 전체 길이 - 윈도우 창 높이 ) * 100; 1234per = Math.round( scrollTop / (document.documentElement.scrollHeight - window.innerHeight) ) * 100; ✅ scrollTop 패럴렉스 구현12345678910window.addEventListener(&quot;scroll&quot;, function (e) { scrollTop = document.documentElement.scrollTop; let per = Math.ceil( (scrollTop / (document.body.scrollHeight - window.outerHeight)) * 100 ); bar.style.height = per + &quot;%&quot;; cloudWrap.style.transform = &quot;translate(0,&quot; + scrollTop / 1.2 + &quot;px)&quot;;}); (윈도우 기준) 스크롤 한 번에 100픽셀씩 이동 모두가 100씩 이동할때 지정한 오브젝트만 100 / 1.2 = 83.3 씩 이동을 하게 되어 느리게 움직이는 느낌 반대로 100 * .8 로 해도 비슷한 결과","link":"/2022/01/15/interactivek/Interactive-scroll/"},{"title":"Element 렌더링","text":"📌 Element 렌더링https://ko.reactjs.org/docs/rendering-elements.html 엘리먼트는 React 앱의 가장 작은 단위 브라우저 DOM 엘리먼트와 달리 React 엘리먼트는 일반 객체이며(plain object) 쉽게 생성할 수 있습니다. React DOM은 React 엘리먼트와 일치하도록 DOM을 업데이트한다 1&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 이 안에 들어가는 모든 엘리먼트를 React DOM에서 관리하기 때문에 이것을 “루트(root)” DOM 노드라고 부른다 React 엘리먼트를 루트 DOM 노드에 렌더링하려면 [ReactDOM.render()](https://ko.reactjs.org/docs/react-dom.html#render)로 전달 UI를 업데이트하는 유일한 방법은 새로운 엘리먼트를 생성하고 이를 ReactDOM.render()로 전달 1234567891011function tick() { const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render(element, document.getElementById(&quot;root&quot;));}setInterval(tick, 1000);","link":"/2022/01/20/react/Element-%EB%A0%8C%EB%8D%94%EB%A7%81/"},{"title":"JSX","text":"📌JSXHello World - React 📌JSX ✅ JSX 소개 ✅ JSX에 표현식 포함하기 ✅ JSX문법 ✅ 기초 사용법 🔸 If문 사용 🔸 AND &amp;&amp; 🔸 OR || 🔸 인라인 스타일링 src/APP.js 불러오기 import로 불러오는 기능을 브라우저에서도 사용하기 위해 번들러를 사용 번들 : 파일을 묶듯이 연결하는 것. 대표적인 것 → 웹팩, Parcel, browserify 1234function App() { return ( ....)} function 키워드를 사용하여 컴포넌트를 만들었다 → 함수 컴포넌트라고 부른다. ✅ JSX 소개1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; JavaScript를 확장한 문법이다. React ‘엘리먼트’를 생성한다. JSX 장점 보기 쉽고 익숙하다 → JS만 사용한 코드와 JSX 비교 높은 활용도 → HTML 태그를 사용하고 컴포넌트도 JSX안에서 작성할 수 있다. 12345678910111213# ReactDOM.render- 컴포넌트를 페이지에 렌더링하는 역할- react-dom 모듈을 불러와 사용# 함수의 파라미터ReactDOM.render(페이지에 렌더링할 내용 JSX형태, JSX를 렌더링할 document 내부 요소 설정)# React.StrictMode- 레거시 기능들을 사용하지 못하게 하는 기능- 옛날 기능을 사용했을 때 경고를 출력 ✅ JSX에 표현식 포함하기1234const name = &quot;Josh Perez&quot;;const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;ReactDOM.render(element, document.getElementById(&quot;root&quot;)); JSX의 중괄호 안에는 유효한 모든 javaScript 표현식을 넣을 수 있다 컴파일이 끝나면, JSX 표현식이 정규 JavaScript 함수 호출이 되고 JavaScript 객체로 인식 ✅ JSX문법 감싸인 요소 리액트 컴포넌트에서 요소 여러 개를 왜 하나의 요소로 꼭 감싸야 하는가? Virtual DOM에서 컴포넌트 변화를 감지해 낼 때 효율적으로 비교할 수 있도록 컴포넌트 내부는 하나의 DOM 트리 구조로 이루어져야 한다는 규칙 또는 리액트 v16 도입된 Fragment 기능 사용 ✅ 기초 사용법 src/index.js에서 직접 고쳐도 되지만 모듈을 분리해 실행만 하게 src/App.js에서 수정해보자 12345678910111213import &quot;./App.css&quot;;function App() { const name = &quot;React&quot;; return ( &lt;div&gt; &lt;h1&gt;{name} 안녕? &lt;/h1&gt; &lt;h2&gt;React Document&lt;/h2&gt; &lt;/div&gt; );}export default App; 🔸 If문 사용 if (어쩌구) {저쩌구} 이게 안된다는 소리 JSX안에서 쓰는 삼항 연산자 → 조건문 ? 조건문 참일때 실행할 코드 : 거짓일 때 실행할 코드 1234function App() { const name = &quot;React&quot;; return &lt;div&gt;{name === &quot;React&quot; ? &lt;h1&gt;check&lt;/h1&gt; : null}&lt;/div&gt;;} 🔸 AND &amp;&amp; 조건이 맞으면 뜨고 안맞으면 안뜨게 &amp;&amp; 연산자로 조건부 렌더링 할 수 있는 이유 → 리액트에서 false를 렌더링할 때는 null과 마찬가지로 아무것도 나타나지 않기 때문 1234function App() { const name = &quot;React&quot;; return &lt;div&gt;{name === &quot;React&quot; &amp;&amp; &lt;h1&gt;react&lt;/h1&gt;}&lt;/div&gt;;} 🔸 OR || undefined만 반환하여 렌더링하는 상황을 만들때 1234function App() { const name = undefined; return &lt;div&gt;{name || &lt;h1&gt;react&lt;/h1&gt;}&lt;/div&gt;;} 🔸 인라인 스타일링 리액트에서 DOM 요소에 스타일을 적용할 때는 문자열 형태로 넣는 것이 아니라 객체 형태로 넣어주어야 한다. 카멜 표기법 → background-color X → backgroundColor JSX에는 class가 아닌 className으로 설정해 주어야 한다. (APP.css에서 설정하고 ) 123456789101112131415function App() { const name = &quot;React&quot;; return ( &lt;div style={{ backgroundColor: &quot;black&quot;, color: &quot;aqua&quot;, fontSize: &quot;48px&quot;, fontWeight: &quot;bold&quot;, }} &gt; {name} &lt;/div&gt; );} 12345678910function App() { const name = &quot;React&quot;; const style = { backgroundColor: &quot;black&quot;, color: &quot;aqua&quot;, fontSize: &quot;48px&quot;, fontWeight: &quot;bold&quot;, }; return &lt;div style={style}&gt;{name}&lt;/div&gt;;} 주석 12345678910111213function App() { const name = &quot;React&quot;; return ( &lt;div&gt; {/* 이렇게 주석 */} &lt;div className=&quot;react&quot; // 이렇게 할수도 있넹 &gt; {name} &lt;/div&gt; &lt;/div&gt; );}","link":"/2022/01/18/react/JSX/"},{"title":"React-Document","text":"📌React DocumentReact - 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리 React는 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리 📌React Document ✅ 선언형 ✅ 컴포넌트 기반 ✅ 간단한 컴포넌트 ✅ 상태를 가지는 컴포넌트 ✅ 외부 플러그인을 사용하는 컴포넌트 ✅ 리액트의 특징 ✅ Create React APP ✅ 선언형 상호작용이 많은 UI를 만들 때 → 어려움을 줄여줌 애플리케이션의 각 상태에 대해 → 뷰 만 설계 데이터가 변경됨에 따라 컴포넌트 → 갱신하고 렌더링 1234567**어떤 데이터가 변할 때마다 어떤 변화를 줄지 고민하는 것이 아니라그냥 기존 뷰를 날려 버리고 처음부터 새로 렌더링하는 방식**- 새롭게 리렌더링하면서 성능을 아끼고, 최적의 UX을 제공할 수 있을까? 데이터 업데이트시 업데이트한 값을 수정하는 것이 아니라, render 함수를 또 다시 호출 이때 render함수가 반환하는 결과를 DOM에 반영하지 않고, 이전에 render 함수가 만든 컴포넌트 정보와 현재 컴포넌트를 비교하여 -&gt; 둘의 차이를 최소한 연산으로 DOM 트리 업데이트 ✅ 컴포넌트 기반 컴포넌트 : 스스로 상태를 관리하는 캡슐화 조합해 복잡한 UI를 만듬 컴포넌트 로직 → 템플릿 X, Javascript로 작성 다양한 형식의 데이터를 앱 안에서 전달, DOM과는 별개로 상태를 관리 123456789# 컴포넌트- React 프로젝트에서 특정 부분이 어떻게 생길지 정하는 선언체- 재사용이 가능한 API로 수 많은 기능들을 내장- 컴포넌트 하나에서 해당 컴포넌트의 생김새와 작동 방식을 정의# 렌더링- 사용자 화면에 뷰를 보여 주는 것 ✅ 간단한 컴포넌트 React 컴포넌트는 render( ) 메서드를 구현 → 데이터를 입력받아 화면에 표시할 내용을 반환하는 역할 컴포넌트로 전달된 데이터는 render( ) 안에서 this.props를 통해 접근 1234# render()- 컴포넌트가 어떻게 생겼는지 정의하는 역할- 뷰가 어떻게 생겼고, 어떻게 작동하는지에 대한 정보를 지닌 객체를 반환 ✅ 상태를 가지는 컴포넌트 컴포넌트는 this.props를 이용해 → 입력 데이터 + 내부적인 상태 데이터를 가짐 이는 this.state로 접근할 수 있다. 컴포넌트의 상태 데이터가 바뀌면 → render()가 다시 호출되어 마크업 갱신 ✅ 외부 플러그인을 사용하는 컴포넌트 React는 다른 라이브러리나 프레임워크 함께 활용 ✅ 리액트의 특징 Virtual DOM을 사용하는 것 DOM : 객체로 문서 구조를 표현하는 방법으로 XML, HTML로 작성 Virtual DOM을 사용하면 → 실제 DOM에 접근하여 조작하는것이 아닌 추상화한 JS 객체를 구성하여 사용 1231. 데이터를 업데이트하면 전체 UI를 Virtual DOM에 리렌더링한다.2. 이전 Virtual DOM에 있던 내용과 현재 내용을 비교한다3. 바뀐 부분만 실제 DOM에 적용한다. ✅ Create React APP123npx create-react-app my-appcd my-appnpm start","link":"/2022/01/16/react/React-Document/"},{"title":"State","text":"📌 StateState and Lifecycle - React props → 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값, props를 바꾸려면 부모 컴포넌트에서 바꾸어 주어야 한다 state → 컴포넌트 내부에서 바뀔 수 있는 값을 의미한다 1234# state는 두가지 종류1. 클래스 컴포넌트 -&gt; state2. 함수 컴포넌트 -&gt; useState 함수를 통해 사용하는 state ✅ 클래스형 컴포넌트의 state1234567class Counter extends Component { constructor(props) { super(props); this.state = { number: 0, }; } state를 설정할 때 → constructor 메서드를 작성하여 설정 → 컴포넌트 생성자 메서드 클래스형 컴포넌트 → constructor 작성할때 반드시 → super(props)를 호출 이 함수가 호출되면 → 현재 클래스 컴포넌트가 상속받고 있는 리액트 component 클래스가 지닌 생성자 함수를 호출해준다 this.state 값에 초깃값 설정 → 컴포넌트의 state는 객체 형식 123456789101112131415render() { const { number } = this.state; return ( &lt;div&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={() =&gt; { this.setState({ number: number + 1 }); }} &gt; +1 &lt;/button&gt; &lt;/div&gt; ); } render 함수 → 현재 state를 조회 → this.state button 안에 onClick 값 props로 넣어줌 → 이벤트 설정 → 클릭 → this.setState → state 값 변경 🔸 state 객체 안에 여러 값이 있을 때12345678910111213141516171819202122232425class Counter extends Component { constructor(props) { super(props); this.state = { number: 0, fixedNumber: 0, }; } render() { const { number, fixedNumber } = this.state; return ( &lt;div&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;h2&gt;바뀌지 않는 값: {fixedNumber}&lt;/h2&gt; &lt;button onClick={() =&gt; { this.setState({ number: number + 1 }); }} &gt; +1 &lt;/button&gt; &lt;/div&gt; ); }} 🔸 state를 constructor에서 꺼내기 state의 초깃값 지정을 위해 constructor 메서드를 선언했는데 또 다른 방식이 있다. 123456class Counter extends Component { state = { number: 0, fixedNumber: 0, }; render() { ...} } 🔸 this.setState에 객체 대신 함수 인자 전달1234onClick ={() =&gt; { this.setState({number: number + 1}) this.setState({number: this.state.number + 1})} this.setState를 두 번 사용하여도 숫자는 1씩 더해진다 → state 값이 바로 바뀌지 않기 때문 이에 해결책 → this.setState에 객체 대신에 함수를 인자로 넣어줌 1234this.setState((prevState, props) =&gt; { return { // 업데이트} prevState → 기존 상태, props → 현재 지니고 있는 props 가리킨다 1234onClick={() =&gt; { this.setState((prevState) =&gt; ({ number: prevState.number + 1,})); 🔸 this.setState 끝난 후 특정 작업 실행 (콜백)12345678910111213141516&lt;button onClick={() =&gt; { this.setState((prevState) =&gt; ({ number: prevState.number + 1, })); this.setState( { number: number + 1, }, () =&gt; { console.log(&quot;setState 호출&quot;); console.log(this.state); } ); }} &gt; ✅ 함수 컴포넌트 useState 함수 컴포넌트는 state 사용 할 수 없었다 → useState 함수를 사용해 state 사용 가능 Hooks를 사용 Hooks 사용 전에 배열 비구조화 할당 12345const array = [1, 2];const one = array[0];// 배열 비구조화 할당const [one, two] = array; 🔸 useState 사용하기 useState 함수의 인자에는 상태의 초깃값을 넣어줌 useState에서는 꼭 객체가 아니라 값의 형태는 자유다 함수를 호출하면 배열이 반환 배열 첫 번째 원소 : 현재상태 배열 두 번째 원소 : 상태를 바꾸어 주는 함수 → Setter 함수 1234567891011121314151617import { useState } from &quot;react&quot;;const Say = () =&gt; { const [message, setMessage] = useState(&quot;&quot;); const onClickEnter = () =&gt; setMessage(&quot;안녕히하세요!&quot;); const onClickLeave = () =&gt; setMessage(&quot;안녕히 가세요~&quot;); return ( &lt;div&gt; &lt;button onClick={onClickEnter}&gt;입장&lt;/button&gt; &lt;button onClick={onClickLeave}&gt;퇴장&lt;/button&gt; &lt;h1&gt;{message}&lt;/h1&gt; &lt;/div&gt; );};export default Say; 🔸 한 컴포넌트에서 useState 여러 번 사용12345678910111213141516171819202122232425262728import { useState } from &quot;react&quot;;const Say = () =&gt; { const [message, setMessage] = useState(&quot;&quot;); const onClickEnter = () =&gt; setMessage(&quot;안녕히하세요!&quot;); const onClickLeave = () =&gt; setMessage(&quot;안녕히 가세요~&quot;); const [color, setColor] = useState(&quot;black&quot;); return ( &lt;div&gt; &lt;button onClick={onClickEnter}&gt;입장&lt;/button&gt; &lt;button onClick={onClickLeave}&gt;퇴장&lt;/button&gt; &lt;h1 style={{ color }}&gt;{message}&lt;/h1&gt; &lt;button style={{ color: &quot;red&quot; }} onClick={() =&gt; setColor(&quot;red&quot;)}&gt; Red &lt;/button&gt; &lt;button style={{ color: &quot;green&quot; }} onClick={() =&gt; setColor(&quot;green&quot;)}&gt; Green &lt;/button&gt; &lt;button style={{ color: &quot;blue&quot; }} onClick={() =&gt; setColor(&quot;blue&quot;)}&gt; Blue &lt;/button&gt; &lt;/div&gt; );};export default Say; ✅ state를 사용할 때 주의사항 state 값을 바꿀 때 → setState 혹은 useState를 통해 전달받은 세터 함수를 사용해야 한다 배열이나 객체를 업데이트해야 할 때는 어떻게 해야 할까? 배열이나 객체 사본을 만들고 그 사본에 값을 업데이트한 후 → 사본 상태를 세터함수를 통해 업데이트","link":"/2022/01/23/react/State/"},{"title":"component와 props를 알아가보자","text":"📌 Component와 PropsComponents와 Props - React 컴포넌트를 통해 UI를 재사용 가능한 개별적인 여러 조각으로 나누고, 각 조각을 개별적으로 살펴볼 수 있다. 개념적으로 컴포넌트는 JavaScript 함수와 유사. “props”라고 하는 임의의 입력을 받은 후, 화면에 어떻게 표시되는지를 기술하는 React 엘리먼트를 반환합니다. ✅함수 컴포넌트와 클래스 컴포넌트123456789# 컴포넌트를 선언하는 방식 두가지1. 함수 컴포넌트2. 클래스형 컴포넌트# 차이점- 클래스형 컴포넌트 -&gt; state 기능 및 라이프 사이클 기능을 사용가능- 임의 메서드를 정의할 수 있다. 🔸 함수형 컴포넌트 컴포넌트를 정의하는 가장 간단한 방법 → JavaScript 함수를 작성 123function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;} 단점 → state와 라이프사이클 API의 사용 불가 → 해결점 → Hooks 기능 도입 🔸 클래스형 컴포넌트 App.js 12345678import { Component } from &quot;react&quot;;class App extends Component { render() { const name = &quot;React&quot;; return &lt;div className=&quot;react&quot;&gt;{name}&lt;/div&gt;; }} render 함수가 꼭 있어야 함 그 안에서 보여 주어야 할 JSX를 반환해야 한다 ✅컴포넌트 렌더링 React 엘리먼트는 사용자 정의 컴포넌트로도 나타낼수 있다. 1const element = &lt;Welcome name=&quot;Sara&quot; /&gt;; Props : React가 사용자 정의 컴포넌트로 작성한 엘리먼트를 발견하면 → JSX 어트리뷰트와 자식을 해당 컴포넌트에 단일 객체로 전달합니다. 이 객체를 props 1234567891011121314function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;}const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;ReactDOM.render( element, document.getElementById('root'));1. &lt;Welcome name=&quot;Sara&quot; /&gt; 엘리먼트로 ReactDOM.render()를 호출합니다.2. React는 {name: 'Sara'}를 props로 하여 Welcome 컴포넌트를 호출합니다.3. Welcome 컴포넌트는 결과적으로 &lt;h1&gt;Hello, Sara&lt;/h1&gt; 엘리먼트를 반환합니다.4. React DOM은 &lt;h1&gt;Hello, Sara&lt;/h1&gt; 엘리먼트와 일치하도록 DOM을 효율적으로 업데이트합니다. ✅ 컴포넌트 합성 컴포넌트는 자신의 출력에 다른 컴포넌트를 참조할 수 있습니다. 123456789101112131415function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;}function App() { return ( &lt;div&gt; &lt;Welcome name=&quot;Sara&quot; /&gt; &lt;Welcome name=&quot;Cahal&quot; /&gt; &lt;Welcome name=&quot;Edite&quot; /&gt; &lt;/div&gt; );}ReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;root&quot;)); ✅첫 컴포넌트 생성 src/[new file].js 12345const MyComponent = () =&gt; { return &lt;div&gt;First new Component&lt;/div&gt;;};export default MyComponent; 일반 함수 vs 화살표 함수 차이 == this 값이 다르다 일반 함수 → 자신이 종속된 객체를 this로 가리킨다 화살표 함수 → 자신이 종속된 인스턴스(new)를 가리킨다 123const App = () =&gt; { return &lt;MyComponent /&gt;;}; ✅Props properties 줄인 표현, 컴포넌트 속성을 설정할 때 사용하는 요소 props 값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트(App.js)에서 설정할 수 있다 123456// MyComponent.jsconst MyComponent = (props) =&gt; { return &lt;div&gt;My name {props.name}&lt;/div&gt;;};export default MyComponent; 12345678// App.jsimport MyComponent from &quot;./MyComponent&quot;;const App = () =&gt; { return &lt;MyComponent name=&quot;⚛️React&quot; /&gt;;};export default App; 🔸Props 기본값 설정 : defaultProps123456789101112const MyComponent = (props) =&gt; { return &lt;div&gt;My name {props.name} 입니다&lt;/div&gt;;};MyComponent.defaultProps = { name: &quot;기본이름&quot;,};// App.jsconst App = () =&gt; { return &lt;MyComponent /&gt;;}; 🔸태그 사이의 내용을 보여주는 Children 컴포넌트 태그 사이의 내용을 보여주는 props children 123const App = () =&gt; { return &lt;MyComponent&gt;react&lt;/MyComponent&gt;;}; 1234567891011const MyComponent = (props) =&gt; { return ( &lt;div&gt; My name {props.name} 입니다 Children value {props.children} &lt;/div&gt; );};MyComponent.defaultProps = { name: &quot;기본이름&quot;,}; 🔸 비구조화 할당 문법 props 키워드를 앞에다 붙이는데 이를 편하기 위해 → 비구조화 할당 문법 사용 123456789const MyComponent = (props) =&gt; { const { name, children } = props; return ( &lt;div&gt; My name {name} 입니다 &lt;br /&gt; Children value {children} &lt;/div&gt; );}; 비구조화 할당 문법 = 구조 분해 문법 함수의 파라미터 부분에도 사용 가능 12const MyComponent = ({ name, children }) =&gt; { return ( ... ) 🔸 클래스형 컴포넌트 Props props 사용 시 → render 함수에서 this.props 1234567891011121314151617181920class MyComponent extends Component { static defaultProps = { name: &quot;기본 이름&quot;, }; static propTypes = { name: PropTypes.string, favoriteNumber: PropTypes.number.isRequired, }; render() { const { name, favoriteNumber, children } = this.props; return ( &lt;div&gt; My name {name} 입니다 &lt;br /&gt; Children value {children} &lt;br /&gt; 좋아하는 숫자 {favoriteNumber} &lt;/div&gt; ); }}","link":"/2022/01/21/react/component-and-props/"},{"title":"자료구조 basic","text":"✅ 정의 대량의 데이터를 효율적으로 관리할 수 있도록 하는 데이터의 구조를 의미합니다. 데이터 특성에 따라서, 체계적인 데이터 구조화가 필요하며, 이러한 데이터 구조는 코드의 효율성, 성능을 결정합니다. ✅ 종류대표적인 자료구조로는 배열(Array), 스택(Stack), 큐(Queue), 링크드 리스트(Linked List), 해쉬 테이블(Hash Table), 힙(Heap) 등이 존재합니다. Python에서는 대표적으로 List, tuple, set, dictionary가 존재하며, 위의 자료구조 대부분을 모두 구현이 가능합니다. 🔥 스택 스택의 추상 자료형 (스택으로 무엇을 할 수 있는가?) 스택이 비어있는지 새로운 항목을 스택에 삽입 스택에서 하나의 항목을 꺼낸다 스택의 현재 개수 맨위 스택이 무엇인지 알려준다 스택을 깨끗이 비운다. 스택은 어디서 사용? 페이지 되돌리기 함수 호출에서 복귀 주소 괄호 닫기 계산기 프로그램 깊이 우선 탐색 🔥 큐 큐는 어디서 사용? 서비스 콜 센터 콜큐 인쇄 작업 큐 버퍼링 시뮬레이션 이진트리의 레벨 순회, 기수정렬에서 레코드의 정렬, 너비우선탐색 🔥 덱 큐의 front 와 rear에서 모두 삽입 삭제가 가능한 큐 🔥 우선순위 큐 모든 데이터가 우선순위를 가지고 있고, 들어온 순서와 상관없이 우선순위가 높은 데이터가 먼저 출력되는 구조 우선순위 큐는 “우선순위”에 따라 스택이나 큐로 얼마든지 사용 우선순위 큐 주요 응용 허프만 코딩 트리 크루스칼 최소비용 신장트리 알고리즘 다익스트라 최단거리 알고리즘 상태공간트리","link":"/2022/01/14/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-basic/"}],"tags":[],"categories":[{"name":"http","slug":"http","link":"/categories/http/"},{"name":"Interactive","slug":"Interactive","link":"/categories/Interactive/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"자료구조","slug":"자료구조","link":"/categories/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"Document","slug":"React/Document","link":"/categories/React/Document/"}]}